Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pom.xml b/pom.xml
--- a/pom.xml	(revision 7ea6bb88ec93ee2375a8b14659701405854d8103)
+++ b/pom.xml	(date 1608333560910)
@@ -180,6 +180,35 @@
             <artifactId>hibernate-core</artifactId>
             <version>5.4.25.Final</version>
         </dependency>
+
+        <!-- https://mvnrepository.com/artifact/org.languagetool/language-en -->
+        <dependency>
+            <groupId>org.languagetool</groupId>
+            <artifactId>language-en</artifactId>
+            <version>5.1</version>
+        </dependency>
+
+        <!-- https://mvnrepository.com/artifact/org.languagetool/language-ru -->
+        <dependency>
+            <groupId>org.languagetool</groupId>
+            <artifactId>language-ru</artifactId>
+            <version>5.1</version>
+        </dependency>
+
+        <!-- https://mvnrepository.com/artifact/org.languagetool/language-uk -->
+        <dependency>
+            <groupId>org.languagetool</groupId>
+            <artifactId>language-uk</artifactId>
+            <version>5.1</version>
+        </dependency>
+
+        <!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 -->
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>1.7.30</version>
+        </dependency>
+
     </dependencies>
 
     <build>
Index: src/main/java/hellfrog/commands/scenes/GrammarScenario.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/hellfrog/commands/scenes/GrammarScenario.java b/src/main/java/hellfrog/commands/scenes/GrammarScenario.java
new file mode 100644
--- /dev/null	(date 1608334648758)
+++ b/src/main/java/hellfrog/commands/scenes/GrammarScenario.java	(date 1608334648758)
@@ -0,0 +1,150 @@
+package hellfrog.commands.scenes;
+
+import hellfrog.common.BroadCast;
+import hellfrog.common.CommonUtils;
+import hellfrog.core.ServerSideResolver;
+import org.javacord.api.entity.channel.PrivateChannel;
+import org.javacord.api.entity.channel.ServerTextChannel;
+import org.javacord.api.entity.message.Message;
+import org.javacord.api.entity.message.embed.EmbedBuilder;
+import org.javacord.api.entity.server.Server;
+import org.javacord.api.entity.user.User;
+import org.javacord.api.event.message.MessageCreateEvent;
+import org.jetbrains.annotations.NotNull;
+import org.languagetool.JLanguageTool;
+import org.languagetool.language.AmericanEnglish;
+import org.languagetool.language.Russian;
+import org.languagetool.language.Ukrainian;
+import org.languagetool.rules.RuleMatch;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class GrammarScenario extends OneShotScenario {
+
+    private static final String PREFIX = "spc";
+    private static final String DESCRIPTION = "Spellchecking text";
+    private final ReentrantLock langToolLock = new ReentrantLock();
+    private final JLanguageTool enTool = new JLanguageTool(new AmericanEnglish());
+    private final JLanguageTool ruTool = new JLanguageTool(new Russian());
+    private final JLanguageTool uaTool = new JLanguageTool(new Ukrainian());
+
+    public GrammarScenario() {
+        super(PREFIX, DESCRIPTION);
+        super.enableStrictByChannels();
+    }
+
+    @Override
+    protected void onPrivate(@NotNull MessageCreateEvent event,
+                             @NotNull PrivateChannel privateChannel,
+                             @NotNull User user,
+                             boolean isBotOwner) {
+        CompletableFuture.runAsync(() -> exec(event));
+    }
+
+    @Override
+    protected void onServer(@NotNull MessageCreateEvent event,
+                            @NotNull Server server,
+                            @NotNull ServerTextChannel serverTextChannel,
+                            @NotNull User user,
+                            boolean isBotOwner) {
+        CompletableFuture.runAsync(() -> exec(event));
+    }
+
+    private void exec(@NotNull final MessageCreateEvent event) {
+
+        final String readableText = super.getReadableMessageContentWithoutPrefix(event);
+        if (CommonUtils.isTrStringEmpty(readableText)) {
+            super.showInfoMessage("Usage: " + PREFIX + " us/ru/ua Your text", event);
+            return;
+        }
+
+        final String[] argAndText = readableText.split(" ", 2);
+        if (argAndText.length < 2) {
+            super.showInfoMessage("Usage: " + PREFIX + " us/ru/ua Your text", event);
+            return;
+        }
+
+        final String rawLang = argAndText[0].toLowerCase();
+        final String checkingText = argAndText[1];
+        final language lang = parseLanguage(rawLang);
+        if (lang.equals(language.UNK)) {
+            super.showErrorMessage("Language " + ServerSideResolver.quoteEveryoneTags(rawLang)
+                    + " is not supported. You can choose: en/us - English, ru - Russian, ua - Ukrainian.", event);
+            return;
+        }
+
+        List<RuleMatch> matches;
+        try {
+            langToolLock.lock();
+            JLanguageTool languageTool = switch (lang) {
+                case RU -> ruTool;
+                case UA -> uaTool;
+                default -> enTool;
+            };
+            try {
+                matches = languageTool.check(checkingText);
+            } catch (IOException err) {
+                String errMsg = String.format("Unable to check text with %s languagetool: %s", lang, err.getMessage());
+                log.error(errMsg, err);
+                BroadCast.sendServiceMessage(errMsg);
+                showErrorMessage("Spellcheck engine error", event);
+                return;
+            }
+        } finally {
+            langToolLock.unlock();
+        }
+
+        StringBuilder highlightText = new StringBuilder(checkingText);
+        StringBuilder errors = new StringBuilder();
+        int shift = 0;
+        int pos = 1;
+        if (matches.isEmpty()) {
+            errors.append("No errors found");
+        } else {
+            for (RuleMatch match : matches) {
+                final String pointText = "`[" + pos + "]";
+                highlightText.insert(match.getFromPos() + shift, pointText);
+                shift += pointText.length();
+                highlightText.insert(match.getToPos() + shift, "`");
+                shift++;
+                errors.append(pos).append(") ")
+                        .append(match.getMessage().replaceAll("</?suggestion>", ""))
+                        .append(match.getSuggestedReplacements()
+                                .stream()
+                                .reduce(CommonUtils::reduceConcat)
+                                .map((s) -> " *(" + s + ")*")
+                                .orElse(""))
+                        .append('\n');
+                pos++;
+            }
+        }
+
+        List<String> listOfMessagesText = CommonUtils.splitEqually(
+                highlightText.toString() + "\n\n" + errors.toString(), 1999);
+        for (String msgText : listOfMessagesText) {
+            EmbedBuilder embedBuilder = new EmbedBuilder()
+                    .setDescription(msgText);
+            Optional<Message> msg = super.displayMessage(embedBuilder, event.getChannel());
+            if (msg.isEmpty()) {
+                return;
+            }
+        }
+    }
+
+    private language parseLanguage(@NotNull final String rawLang) {
+        return switch (rawLang) {
+            case "en", "us" -> language.US;
+            case "ru" -> language.RU;
+            case "ua" -> language.UA;
+            default -> language.UNK;
+        };
+    }
+
+    private enum language {
+        US, RU, UA, UNK
+    }
+}
